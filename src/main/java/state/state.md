#设计模式20 状态模式 State Pattern
#### 定义
Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.
当一个对象内在状态改变时允许其改变行为，这个对象看起来改变了其类。 

状态模式的核心是封装，状态的变更引起了行为的变更，从外部看起来就好像这个对象对应的类发生了改变一样。


#### 结构
(img)

- State 抽象状态角色
	接口或者抽象类，负责对象状态的定义，并且封装环境角色以实现状态切换。
- ConcreteState 具体状态角色
	每一个具体的状态角色需要完成两个职责：本状态的行为管理以及趋向状态处理，通俗地说，就是本状态下要做的事情，以及本状态如何过度到其他状态。
- Context 环境角色
	定义客户端需要的接口，并且负责具体状态的切换。
主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同的一系列类当中，可以把复杂的逻辑判断简单化。


#### 优点
1. 结构清晰
	避免了过多的swith case 或者if else 语句，避免了程序的复杂性，提供系统的可维护性。状态模式通过把各种状态转移逻辑分不到State的子类之间，来减少相互间的依赖
2. 遵循设计原则
	很好的体现了开闭原则和单一职责原则，每一个状态都是一个子类，需要增加状态则增加子类便可，如要修改状态也只需要修改一个子类。
3. 封装性非常好
	状态模式将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。
4. 它使得状态转换显式化: 
	当一个对象仅以内部数据值来定义当前状态时 , 其状态仅表现为对一些变量的赋值，这不够明确。为不同的状态引入独立的对象使得转换变得更加明确。而且, State对象可保证Context不会发生内部状态不一致的情况，因为从 Context的角度看，状态转换是原子的—只需重新绑定一个变量(即Context的State对象变量)，而无需为多个变量赋值

#### 缺点
- 状态模式的使用必然会增加系统类和对象的个数。
- 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。