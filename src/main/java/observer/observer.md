#设计模式16 观察者模式  Observer Pattern

#### 定义
Define a one-to-many dependency between objects so that when one object changes status, all its dependents are notified and updated automatically.
定义对象之间一种一对多的依赖关系，使得每一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。


#### 结构
- Subject 被观察者
	定义被观察者必须实现的职责，它必须能够动态地增加、取消观察者。它一般是抽象类或者是实现类，仅仅完成作为被观察者必须实现的职责：管理观察者和通知观察者。
- Observer 观察者
	观察者在收到消息后，即进行update操作，对收到的消息进行处理。
- ConcreteSubject 具体的被观察者
	定义被观察者自己的业务逻辑，同时定义对那些事件进行通知。
- ConcreteObserver 具体的观察者
	每个观察者在接收到消息后的处理是不同的，各个观察者具有自己的处理逻辑。
在程序用使用ArrayList 和Vector没有太多的区别，ArrayList 是线程异步，不安全；Vector是线程同步，安全。所以看实际情况选择数据结构。


#### 优点
- 观察者和被观察者之间是抽象耦合
	这样定义，不管是增加观察者还是被观察者都会非常容易。
- 建立一套触发机制
	根据单一职责原则，每个类的职责都是单一的。观察者模式可以完美的实现这样一个触发链。

#### 缺点
使用观察者模式时需要考虑一下开发效率和运行效率的问题，一个被观察者，多个观察者，开发和调试都会比较复杂，而且在java中消息的通知默认是顺序执行，一个观察者卡壳，会影响整体的执行效率。在这样的情况下，一般考虑异步处理的方式。
多级触发的效率问题更加让人担忧，大家在设计时注意考虑。

#### 使用场景
- 关联行文场景，需要注意的是，关联行为是不可才分的，不是组合关系。
- 事件多级触发场景
- 夸系统的消息交互场景，如消息队列处理机制。

####注意事项
1. 广播连问题
	触发链问题：比如表A上写了一个触发器，内容是一个字段更新完了之后更新表B中的一条数据，而表B上同样有一个触发器，需要触发更新表C这样就形成了一个触发链。观察者模式也是一样，如果一个观察可以有双重身份，及时观察者也是被观察者，这样的链一旦被建立，这个逻辑就会比较复杂，可维护性就会变差。在一个观察者模式中最多出现一个对象及时观察也是被观察者，也就是说消息最多没转发一次。
2. 异步处理问题
	这个EJB是非常好的例子，被观察者发生动作了，观察者要做出做出回应，如果观察者比较多，热切处理时间比较长怎么办。考虑采用异步处理模式，异步处理需要考虑线程安全和队列问题。建议看看Message Queue。
