#设计模式12：迭代器模式 Iterator Pattern

# 定义
Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.
提供一种方法访问一个容器对象中的各个元素，而又不需要暴露改对象的内部细节。

从定义可见，迭代器模式是为容器而生。很明显，对容器对象的访问必然涉及到遍历算法。你可以一股脑的将遍历方法塞到容器对象中去；或者根本不去提供什么遍历算法，让使用容器的人自己去实现去吧。这两种情况好像都能够解决问题。

　　然而在前一种情况，容器承受了过多的功能，它不仅要负责自己“容器”内的元素维护（添加、删除等等），而且还要提供遍历自身的接口；而且由于遍历状态保存的问题，不能对同一个容器对象同时进行多个遍历。第二种方式倒是省事，却又将容器的内部细节暴露无遗。

# 结构
类图
(img)

- Iterator 抽象迭代器
	抽象迭代器负责定义访问和遍历元素的接口，而且基本上有3个固定的方法，fist()获取第一个元素，next()获取下一个元素，hasNext()是否访问到容器底部。
- ConcreteIterator 具体迭代器
	实现抽象类的接口，完成迭代器的遍历。
- Aggregate 抽象容器
	容器角色负责提供创建迭代器角色的接口，必然提供一个类似createIrerator()这样的接口。
- ConcreteAggregate 具体容器
	实现抽象类的接口。


从结构上可以看出，迭代器模式在客户与容器之间加入了迭代器角色。迭代器角色的加入，就可以很好的避免容器内部细节的暴露，而且也使得设计符号“单一职责原则”。

　　注意，在迭代器模式中，具体迭代器角色和具体容器角色是耦合在一起的——遍历算法是与容器的内部细节紧密相关的。为了使客户程序从与具体迭代器角色耦合的困境中脱离出来，避免具体迭代器角色的更换给客户程序带来的修改，迭代器模式抽象了具体迭代器角色，使得客户程序更具一般性和重用性。这被称为多态迭代。
意图：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。

主要解决：不同的方式来遍历整个整合对象。
何时使用：遍历一个聚合对象。
如何解决：把在元素之间游走的责任交给迭代器，而不是聚合对象。
关键代码：定义接口：hasNext, next。
应用实例：JAVA 中的 iterator。
优点： 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。
缺点：由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。

# 适用情况 

　　由上面的讲述，我们可以看出迭代器模式给容器的应用带来以下好处：
1. 支持以不同的方式遍历一个容器角色。根据实现方式的不同，效果上会有差别。
2. 简化了容器的接口。但是在java Collection中为了提高可扩展性，容器还是提供了遍历的接口。
3. 对同一个容器对象，可以同时进行多个遍历。因为遍历状态是保存在每一个迭代器对象中的。
　　由此也能得出迭代器模式的适用范围：
- 访问一个容器对象的内容而无需暴露它的内部表示。
- 支持对容器对象的多种遍历。
- 为遍历不同的容器结构提供一个统一的接口（多态迭代）。

